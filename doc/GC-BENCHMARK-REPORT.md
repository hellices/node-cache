# In-Memory Cache GC 성능 분석 보고서

**테스트 일시**: 2026년 1월 30일  
**테스트 환경**: Node.js + MySQL (Docker)

---

## 1. 테스트 개요

### 목적
- 인메모리 캐시 사용 시 GC(Garbage Collection) 빈도 및 지연 감소 효과 검증
- 객체 재사용을 통한 메모리 할당 감소 측정

### 테스트 구성

| 항목 | 값 |
|------|-----|
| 총 요청 수 | 2,000회 (20 iterations × 100 concurrency) |
| 서비스 수 | 20개 (랜덤 선택) |
| 테스트당 variants | 5개 |
| 서버 Old Space 제한 | 256MB (`--max-old-space-size=256`) |

### 비교 대상

| 방식 | 설명 |
|------|------|
| **DB 직접 조회** | 매 요청마다 MySQL 쿼리 → 객체 변환 → 응답 |
| **인메모리 캐시** | 서버 시작 시 로드 → 캐시된 객체 재사용 |

---

## 2. 테스트 결과

### 2.1 GC 이벤트 비교

| 지표 | DB 직접 조회 | 캐시 사용 | 절감 | 개선율 |
|------|-------------|-----------|------|--------|
| **총 GC 횟수** | 1,190 | 238 | 952회 | **80% 감소** |
| Minor GC (Scavenge) | 950 | 220 | 730회 | 77% 감소 |
| Major GC (Mark-Sweep) | 0 | 0 | - | - |
| Incremental Marking | 120 | 9 | 111회 | 93% 감소 |
| WeakCallback | 120 | 9 | 111회 | 93% 감소 |

### 2.2 GC 지연 시간

| 지표 | DB 직접 조회 | 캐시 사용 | 절감 |
|------|-------------|-----------|------|
| **총 GC 지연** | 2,496ms | 540ms | **1,956ms (78%)** |
| 요청당 GC 지연 | 1.25ms | 0.27ms | 0.98ms |

### 2.3 메모리 해제량

| 지표 | DB 직접 조회 | 캐시 사용 | 비율 |
|------|-------------|-----------|------|
| **총 해제 메모리** | 2,202.76 MB | 174.45 MB | **12.6배 차이** |
| GC당 평균 해제 | 1,895.49 KB | 750.57 KB | 2.5배 차이 |
| 요청당 메모리 할당 (추정) | ~1.1 MB | ~87 KB | **12.6배 차이** |

### 2.4 처리량 비교

| 지표 | DB 직접 조회 | 캐시 사용 | 개선 |
|------|-------------|-----------|------|
| 소요 시간 | 46,384ms | 20,627ms | 56% 단축 |
| **처리량 (RPS)** | 43 | 97 | **2.2배 향상** |
| **평균 응답 시간** | 1,178.75ms | 0.09ms | **13,000배 향상** |

---

## 3. 핵심 인사이트

### 3.1 GC 빈도 감소 원리

```
┌─────────────────────────────────────────────────────────────────┐
│                    DB 직접 조회 (매 요청)                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  요청 1 → [DB 쿼리 결과] → [JSON 파싱] → [변환 객체] → 응답      │
│  요청 2 → [DB 쿼리 결과] → [JSON 파싱] → [변환 객체] → 응답      │
│  요청 3 → [DB 쿼리 결과] → [JSON 파싱] → [변환 객체] → 응답      │
│  ...                                                             │
│                                                                  │
│  → 매번 새 객체 생성 → Young Generation 폭발 → Minor GC 950회   │
│  → 2,202 MB 메모리 할당/해제                                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    인메모리 캐시 (객체 재사용)                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  서버 시작 → [캐시 로드] → Old Generation으로 승격               │
│                                                                  │
│  요청 1 → [캐시 참조] → 응답                                    │
│  요청 2 → [캐시 참조] → 응답                                    │
│  요청 3 → [캐시 참조] → 응답                                    │
│  ...                                                             │
│                                                                  │
│  → 새 객체 생성 최소화 → Minor GC 220회 (77% 감소)              │
│  → 174 MB 메모리 할당/해제 (12.6배 감소)                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 GC 유형별 분석

| GC 유형 | 역할 | DB 조회 시 | 캐시 시 | 영향 |
|---------|------|-----------|---------|------|
| **Minor (Scavenge)** | Young Gen 정리, 짧고 빈번 | 950회 | 220회 | 애플리케이션 지연 유발 |
| **Incremental** | 점진적 마킹 | 120회 | 9회 | 백그라운드 작업 |
| **WeakCallback** | 약한 참조 정리 | 120회 | 9회 | 백그라운드 작업 |
| **Major (Mark-Sweep)** | Old Gen 정리, 드물지만 긴 지연 | 0회 | 0회 | (테스트 시간 짧아 미발생) |

### 3.3 객체 생성량 추정

메모리 해제량 기준으로 객체 생성량 추정:

| 방식 | 해제 메모리 | 추정 객체 수 (평균 1KB 가정) |
|------|------------|---------------------------|
| DB 직접 조회 | 2,202 MB | **~2,200,000개** |
| 캐시 사용 | 174 MB | **~174,000개** |

→ **캐시 사용 시 객체 생성량 92% 감소**

---

## 4. 운영 환경 시뮬레이션

### 1,000 RPS 환경 예측 (2,000회 결과 기반)

| 지표 | DB 직접 조회 | 캐시 사용 | 절감 |
|------|-------------|-----------|------|
| GC 횟수/초 | ~25.6회 | ~5.1회 | 20.5회/초 |
| GC 지연/초 | ~53.8ms | ~11.6ms | 42.2ms/초 |
| 메모리 할당/초 | ~47.5 MB | ~3.8 MB | 43.7 MB/초 |
| **시간당 GC 지연** | **193.7초 (3.2분)** | **41.8초** | **151.9초 절감** |
| **시간당 메모리 할당** | **171 GB** | **13.5 GB** | **157.5 GB 절감** |

### P99 응답 시간 안정화

- DB 조회: GC pause 중 응답 지연 발생 가능 (1~10ms 추가)
- 캐시: GC 빈도 감소로 P99 응답 시간 안정화

---

## 5. 결론

### 핵심 성과

| 지표 | 개선율 |
|------|--------|
| GC 횟수 | **80% 감소** (1,190 → 238) |
| GC 지연 시간 | **78% 감소** (2,496ms → 540ms) |
| 메모리 할당량 | **92% 감소** (2,202MB → 174MB) |
| 처리량 | **2.2배 향상** |
| 응답 시간 | **13,000배 향상** |

### 캐시 적용 효과

1. **GC 압력 감소**: 객체 재사용으로 Young Generation 부담 감소
2. **응답 지연 안정화**: GC pause로 인한 tail latency 감소
3. **처리량 향상**: DB I/O 제거 + GC 오버헤드 감소
4. **메모리 효율성**: 동일 메모리로 더 많은 요청 처리 가능

### 적용 권장 사항

| 상황 | 권장 |
|------|------|
| 자주 조회되는 데이터 | ✅ 캐시 적용 권장 |
| 변경이 드문 설정 데이터 | ✅ 캐시 적용 권장 |
| 실시간 변경이 필요한 데이터 | ⚠️ 캐시 무효화 전략 필요 |
| 대용량 데이터 | ⚠️ 메모리 제한 고려 (LRU 등) |

---

## 부록: 테스트 명령어

```bash
# 서버 실행 (GC 추적 활성화)
npm run start:gc-stress

# 벤치마크 실행
node scripts/benchmark-gc.js

# 대규모 테스트
cross-env BENCHMARK_ITERATIONS=100 CONCURRENCY=300 node scripts/benchmark-gc.js
```
